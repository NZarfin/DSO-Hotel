pipeline {
    agent any

    environment {
        FLASK_IMAGE = 'flask:dev'
        MYSQL_IMAGE = 'mysql:dev'
        DEV_BRANCH = 'dev2'
        DEPLOY_BRANCH = 'production'
        HTTP_STATUS = 0  // Add environment variable to store HTTP status
    }

    stages {
        stage('Git Branch Checkout') {
            steps {
                script {
                    def branch = env.BRANCH_NAME
                    echo "Checking out branch: ${DEV_BRANCH}"
                    git branch: "${DEV_BRANCH}", url: 'https://github.com/NZarfin/DSO-Hotel.git'
                }
            }
        }

        stage('Build Docker Images') {
            steps {
                echo 'Building Docker images for Flask and MySQL...'
                sh '''
                    docker build . -t ${FLASK_IMAGE} -f Dockerfile.flask2
                    docker build . -t ${MYSQL_IMAGE} -f Dockerfile.mysql
                '''
            }
        }

        stage('Run Linting on All of Source Code Files') {
            steps {
                echo 'Running linting on Flask app...'
                sh '''
                    docker run --rm ${FLASK_IMAGE} flake8 ../code | tee outputs-log/flake8/flake8_output_$(date +"%Y%m%d_%H%M%S").log
                    docker run --rm ${FLASK_IMAGE} pylint ../code/hotel_management/ | tee outputs-log/pylint/pylint_output_$(date +"%Y%m%d_%H%M%S").log
                '''
            }
        }

        stage('Run Security Checks') {
            steps {
                echo 'Running security checks on Flask app...'
                sh '''
                    docker run --rm ${FLASK_IMAGE} bandit -r ../code | tee outputs-log/bandit/bandit_output_$(date +"%Y%m%d_%H%M%S").log
                '''
            }
        }

        stage('Run Unit Tests') {
            steps {
                echo 'Running unit tests...'
                sh '''
                    echo "Dev1 is producing tests for the Flask app and will integrate the rest of the tests..."
                '''
            }
        }

        stage('Check with httpd') {
            steps {
                echo 'Running security checks with httpd and false data...'
                script {
                    try {
                        sh '''
                            docker run -d --name my_flask_app -p 8010:8081 ${FLASK_IMAGE} flask run
                            
                            # Wait for the app to start
                            sleep 5
                            
                            # Basic httpd check
                            STATUS=$(curl -o /dev/null -s -w "%{http_code}\n" http://localhost:8010)
                            
                            if [ "$STATUS" -ne 200 ]; then
                                echo "App is not responding correctly! Status: $STATUS"
                                exit 1
                            fi
                            
                            echo "App is running. Checking for false data insertion..."
                            
                            # Attempt to inject false data
                            RESPONSE=$(curl -s -X POST http://localhost:8010/insert_fake_data -d '{"name": "fake_data"}' -H "Content-Type: application/json")
                            
                            if echo "$RESPONSE" | grep -q "Error"; then
                                echo "Error in inserting false data: $RESPONSE"
                                exit 1
                            else
                                echo "False data successfully blocked!"
                            fi
                        '''
                        env.HTTP_STATUS = 200  // Set status to 200 if check passes
                    } catch (Exception e) {
                        env.HTTP_STATUS = 500  // Set status to 500 if it fails
                    } finally {
                        sh 'docker stop my_flask_app'
                        sh 'docker rm my_flask_app'
                    }
                }
            }
        }

        stage('Push to Deployment Branch') {
            when {
                branch "${DEV_BRANCH}"
            }
            steps {
                script {
                    if (env.HTTP_STATUS == '200') {
                        echo "HTTP check passed with status code 200. Pushing changes..."
                        sh '''
                            git checkout ${DEPLOY_BRANCH}
                            git merge ${DEV_BRANCH}
                            git push origin ${DEPLOY_BRANCH}
                        '''
                    } else {
                        echo "HTTP check failed, skipping push to deployment branch."
                        currentBuild.result = 'FAILURE'
                        error('HTTP check failed. Not pushing to deployment branch.')
                    }
                }
            }
        }

        stage('Deploy') {
            when {
                branch "${DEPLOY_BRANCH}"
            }
            steps {
                echo 'Deploying to production...'
                sh 'docker-compose up -d'
            }
        }

        stage('Clean Up') {
            steps {
                echo 'Cleaning up Docker images and containers...'
                sh '''
                    docker system prune -f
                    docker rmi ${FLASK_IMAGE} ${MYSQL_IMAGE}
                '''
            }
        }
    }

    post {
        always {
            echo "Pipeline completed."
            archiveArtifacts artifacts: '**/logs/*.log', allowEmptyArchive: true
            cleanWs()
        }

        success {
            echo 'Pipeline completed successfully!'
        }

        failure {
            echo 'Pipeline failed!'
            emailext to: 'n.zrfin@icloud.com',
                     subject: "Build failed in Jenkins: ${env.BUILD_URL}",
                     body: "Check Jenkins logs for more details."
        }
    }
}
